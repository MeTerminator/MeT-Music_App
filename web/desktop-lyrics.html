<!doctype html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MeT-Music 桌面歌词</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            user-select: none;
            box-sizing: border-box;
            -webkit-user-drag: none;
        }

        :root {
            --lyric-font-size: 36;
            --trans-font-size: 18;
            --main-color: #fff;
            --resize-border-width: 6px;
            --color-active: #fff;
            --color-inactive: rgba(255, 255, 255, 0.3);
        }

        body {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            height: 100vh;
            padding: 12px;
            color: var(--main-color);
            overflow: visible;
            scrollbar-width: none;
            transition: opacity 0.3s;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        /* ---------------------------------------------------- */
        /* 1. 窗口拖拽层 (用于移动窗口) */
        /* ---------------------------------------------------- */
        body .drag-area {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 16px;
            /* 歌词主体可以拖动：背景透明 */
            background-color: transparent;
            backdrop-filter: blur(0);
            z-index: 0;
            opacity: 1;
            /* 默认移动光标 */
            cursor: grab;
            transition: background-color 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;

            /* 歌词内容区禁止拖拽 */
            &~header,
            &~main {
                -webkit-app-region: no-drag;
            }
        }

        /* 鼠标悬停时给一个视觉提示 */
        body:hover .drag-area {
            background-color: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            cursor: grab;
        }

        /* 正在拖动时 */
        body.is-dragging .drag-area {
            cursor: grabbing;
        }

        /* ---------------------------------------------------- */
        /* 2. 边框/拉伸把手 (用于拉伸窗口) */
        /* ---------------------------------------------------- */

        .resize-handle {
            position: absolute;
            z-index: 10;
            /* 确保在拖拽层之上 */
            /* 默认隐藏，鼠标悬停时显示 */
            background-color: transparent;
            border: 1px solid transparent;
            opacity: 0;
            transition: opacity 0.3s;
        }

        /* 鼠标悬停 body 时显示边框 */
        body:hover .resize-handle {
            opacity: 1;
        }

        /* 四条边 - 突出边框 */
        .resize-top,
        .resize-bottom {
            left: var(--resize-border-width);
            right: var(--resize-border-width);
            height: var(--resize-border-width);
            border-top: 1px solid rgba(0, 0, 0, 0.8);
            border-bottom: 1px solid rgba(0, 0, 0, 0.8);
        }

        .resize-left,
        .resize-right {
            top: var(--resize-border-width);
            bottom: var(--resize-border-width);
            width: var(--resize-border-width);
            border-left: 1px solid rgba(0, 0, 0, 0.8);
            border-right: 1px solid rgba(0, 0, 0, 0.8);
        }

        .resize-top {
            top: 0;
            cursor: n-resize;
            border-bottom: none;
        }

        .resize-bottom {
            bottom: 0;
            cursor: s-resize;
            border-top: none;
        }

        .resize-left {
            left: 0;
            cursor: w-resize;
            border-right: none;
        }

        .resize-right {
            right: 0;
            cursor: e-resize;
            border-left: none;
        }

        /* 四个角 - 绘制角点 */
        .resize-top-left,
        .resize-top-right,
        .resize-bottom-left,
        .resize-bottom-right {
            width: var(--resize-border-width);
            height: var(--resize-border-width);
            z-index: 11;
            border: 1px solid rgba(0, 0, 0, 0.8);
        }

        .resize-top-left {
            top: 0;
            left: 0;
            cursor: nwse-resize;
        }

        .resize-top-right {
            top: 0;
            right: 0;
            cursor: nesw-resize;
        }

        .resize-bottom-left {
            bottom: 0;
            left: 0;
            cursor: nesw-resize;
        }

        .resize-bottom-right {
            bottom: 0;
            right: 0;
            cursor: nwse-resize;
        }


        /* 锁定歌词状态 */
        body.lock-lyric {
            cursor: none;
            pointer-events: none;

            * {
                pointer-events: none;
            }

            /* 锁定后隐藏拖拽层和拉伸把手 */
            & .drag-area:hover,
            & .resize-handle {
                opacity: 0 !important;
                background-color: transparent !important;
            }
        }

        header {
            z-index: 20;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            position: absolute;
            top: 4px;
            right: 4px;

            .tools {
                display: flex;
                align-items: center;
                justify-content: center;
                opacity: 0;
                transition: opacity 0.3s;
                gap: 4px;

                .item {
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    padding: 2px;
                    border-radius: 4px;
                    cursor: pointer;
                    pointer-events: auto;
                    transition:
                        transform 0.3s,
                        background-color 0.3s;

                    &:hover {
                        background-color: rgba(0, 0, 0, 0.4);
                    }

                    &:active {
                        transform: scale(0.95);
                    }

                    svg {
                        width: 16px;
                        height: 16px;
                    }
                }
            }
        }

        body:hover header .tools {
            opacity: 1;
        }

        body.lock-lyric:hover header .tools {
            opacity: 0;
        }

        main {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            padding: 0 12px;
            z-index: 1;
            pointer-events: auto;
            text-align: center;
            overflow: hidden;
            justify-content: center;
        }

        #lyric-text {
            font-size: calc(var(--lyric-font-size) * 1px);
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            flex-wrap: wrap;
            max-width: 100%;
            line-height: 1.35;
            flex-shrink: 1;
        }

        #lyric-tran {
            font-size: calc(var(--trans-font-size) * 1px);
            margin-top: 4px;
            opacity: 0.6;
            text-align: center;
            max-width: 100%;
            flex-wrap: wrap;
            line-height: 1.3;
            flex-shrink: 0;
            color: var(--main-color);
        }

        /* ---------------------------------------------------- */
        /* KTV 歌词核心样式 */
        /* ---------------------------------------------------- */

        .ktv-line {
            display: inline-block;
            font-weight: bold;
            background-image: linear-gradient(to right, var(--color-active) 50%, var(--color-inactive) 50%);
            background-size: 200% 100%;
            background-position-x: 100%;
            background-repeat: no-repeat;
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            -webkit-text-fill-color: transparent;
            will-change: background-position-x;
            white-space: pre-wrap;
        }
    </style>
</head>

<body>
    <header>
        <div class="tools" id="tools">
            <div id="lock-lyric" class="item" title="锁定/解锁">
                <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24">
                    <path fill="currentColor"
                        d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2M9 6c0-1.66 1.34-3 3-3s3 1.34 3 3v2H9zm9 14H6V10h12zm-6-3c1.1 0 2-.9 2-2s-.9-2-2-2s-2 .9-2 2s.9 2 2 2" />
                </svg>
            </div>
            <div id="close-lyric" class="item" title="关闭">
                <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24">
                    <path fill="currentColor"
                        d="M13.46 12L19 17.54V19h-1.46L12 13.46L6.46 19H5v-1.46L10.54 12L5 6.46V5h1.46L12 10.54L17.54 5H19v1.46z" />
                </svg>
            </div>
        </div>
    </header>

    <div class="drag-area">
        <main id="lyric-content">
            <div id="lyric-text"></div>
            <div id="lyric-tran"></div>
        </main>
    </div>

    <div class="resize-handle resize-top" data-direction="top"></div>
    <div class="resize-handle resize-bottom" data-direction="bottom"></div>
    <div class="resize-handle resize-left" data-direction="left"></div>
    <div class="resize-handle resize-right" data-direction="right"></div>
    <div class="resize-handle resize-top-left" data-direction="top-left"></div>
    <div class="resize-handle resize-top-right" data-direction="top-right"></div>
    <div class="resize-handle resize-bottom-left" data-direction="bottom-left"></div>
    <div class="resize-handle resize-bottom-right" data-direction="bottom-right"></div>


    <script>
        class LyricsWindow {
            constructor() {
                this.lyricTextDom = document.getElementById("lyric-text");
                this.lyricTranDom = document.getElementById("lyric-tran");
                // 窗口移动拖拽状态
                this.isDragging = false;
                this.startX = 0;
                this.startY = 0;
                this.startWinX = 0;
                this.startWinY = 0;
                this.winWidth = 0;
                this.winHeight = 0;
                // 窗口拉伸状态
                this.isResizing = false;
                this.resizeDirection = "";

                this.menuClick();
                this.setupIPCListeners();

                // 窗口移动事件监听（从 drag-area 元素触发）
                document.querySelector(".drag-area").addEventListener("mousedown", this.startDrag.bind(this));

                // 窗口拉伸事件监听（从 resize-handle 元素触发）
                this.setupWindowResizeListeners();

                // 全局的 move/up 监听
                document.addEventListener("mousemove", this.handleMove.bind(this));
                document.addEventListener("mouseup", this.endInteraction.bind(this));

                this.initLockState();
            }

            updateLyrics(lyricText = "", translation = "", lyricData = null) {
                const lineDom = this.lyricTextDom;

                // 空歌词
                if (!lyricData || lyricData.length === 0) {
                    lineDom.textContent = lyricText;
                    lineDom.className = "";
                    this.lyricTranDom.textContent = translation;
                    return;
                }

                let percent = 0;
                let isNewLine = false;

                if (lyricData && lyricData.length > 0) {
                    let words = lyricData;
                    let currentIndex = words.findIndex(w => w.percent < 1);
                    if (currentIndex === -1) currentIndex = words.length;
                    let wordPercent = (currentIndex < words.length ? words[currentIndex].percent : 1);
                    percent = (currentIndex + wordPercent) / words.length;
                }

                // 限制范围
                percent = Math.max(0, Math.min(1, percent));
                if (percent <= 0) {
                    isNewLine = true;
                }

                // 计算目标位置 (0% 是全亮，100% 是全暗)
                const targetPos = Math.max(0, (1 - percent) * 100).toFixed(2) + "%";
                if (isNewLine) {
                    // 彻底禁用动画
                    lineDom.style.transition = "none";

                    // 更新歌词内容和设置初始位置 (100% 全暗)
                    lineDom.innerHTML = lyricText;
                    lineDom.className = "ktv-line";

                    // 确保新行开始时，背景位置是 100%（全暗），为下一步的无动画更新做准备
                    lineDom.style.backgroundPositionX = `100%`;

                    void lineDom.offsetHeight; // 读取 offsetHeight 来强制回流
                }

                // --- 设置整行遮罩进度 ---

                // 恢复动画
                if (!isNewLine) {
                    lineDom.style.transition = "background-position-x 0.25s linear";
                }

                // 设置目标位置
                lineDom.style.backgroundPositionX = targetPos;

                // 为新行在下一帧启用动画
                // 如果是新行，必须在当前帧的位置更新完成后，在下一帧恢复动画，否则后续进度不会动。
                if (isNewLine) {
                    setTimeout(() => {
                        lineDom.style.transition = "background-position-x 0.25s linear";
                    }, 0);
                }

                // 更新歌词和翻译
                lineDom.textContent = lyricText;
                this.lyricTranDom.innerHTML = translation;
            }


            // 初始化锁定状态
            async initLockState() {
                document.body.classList.toggle("lock-lyric", false);
            }

            menuClick() {
                const toolsDom = document.getElementById("tools");
                if (!toolsDom) return;
                toolsDom.addEventListener("click", async (event) => {
                    // 确保点击事件发生在可交互的按钮上
                    const target = event.target.closest(".item");
                    if (!target) return;
                    const id = target.id;
                    if (!id) return;

                    switch (id) {
                        case "close-lyric":
                            // 通知主进程隐藏窗口
                            window.electron.ipcRenderer.send("hide-desktop-lyric-window");
                            break;
                        case "lock-lyric":
                            // 切换锁定状态，并通知主进程
                            const newLockState = !document.body.classList.contains("lock-lyric");
                            document.body.classList.toggle("lock-lyric", newLockState);
                            window.electron.ipcRenderer.send("toggle-desktop-lyric-lock", newLockState);
                            break;
                    }
                });
            }

            setupIPCListeners() {
                // 更新歌曲信息
                window.electron.ipcRenderer.on("play-song-change", (_, title) => {
                    if (!title) return;
                    const [songName, songArtist] = title.split(" - ");
                    // console.log(`Now playing: ${songName} by ${songArtist}`);
                });

                // 更新歌词
                window.electron.ipcRenderer.on("play-lyric-change", (_, data) => {
                    if (!data) return;
                    const { lyricText, lyricTrans, lyricData } = data;

                    if (!lyricText || lyricText.length === 0) {
                        this.updateLyrics("该歌曲暂无歌词", "", null);
                        return;
                    }

                    this.updateLyrics(lyricText, lyricTrans || "", lyricData);
                });

                // 锁定状态变化
                window.electron.ipcRenderer.on("toggle-desktop-lyric-lock-from-main", (_, lock) => {
                    document.body.classList.toggle("lock-lyric", lock);
                });

                // 是否播放
                window.electron.ipcRenderer.on("play-status-change", (_, isPlaying) => {
                    if (!isPlaying) {
                        // 暂停时，body 变透明
                        document.body.style.opacity = "0.3";
                    } else {
                        // 播放时，body 恢复不透明
                        document.body.style.opacity = "1";
                    }
                });
            }

            /* ---------------------------------------------------- */
            /* 窗口移动逻辑 */
            /* ---------------------------------------------------- */

            async startDrag(event) {
                // 确保只有在非锁定状态下才能拖拽
                if (document.body.classList.contains("lock-lyric")) return;

                // 避免点击工具按钮时触发拖拽
                if (event.target.closest(".item")) return;

                this.isDragging = true;
                document.body.classList.add("is-dragging"); // 添加类用于光标改变

                const { screenX, screenY } = event;
                const { x: winX, y: winY, width, height } = await window.electron.ipcRenderer.invoke("get-window-bounds");

                this.startX = screenX;
                this.startY = screenY;
                this.startWinX = winX;
                this.startWinY = winY;
                this.winWidth = width;
                this.winHeight = height;
            }

            dragWindow(event) {
                if (!this.isDragging) return;
                const { screenX, screenY } = event;

                // 1. 计算偏移量
                const deltaX = screenX - this.startX;
                const deltaY = screenY - this.startY;

                // 2. 计算新的绝对位置
                let newWinX = this.startWinX + deltaX;
                let newWinY = this.startWinY + deltaY;

                // 3. 将新的绝对位置发送给主进程。
                window.electron.ipcRenderer.send("move-window", newWinX, newWinY);
            }

            /* ---------------------------------------------------- */
            /* 窗口拉伸逻辑 */
            /* ---------------------------------------------------- */

            setupWindowResizeListeners() {
                document.querySelectorAll(".resize-handle").forEach(handle => {
                    handle.addEventListener("mousedown", this.startResize.bind(this));
                });
            }

            async startResize(event) {
                // 确保只有在非锁定状态下才能拉伸
                if (document.body.classList.contains("lock-lyric")) return;

                // 阻止事件传播，避免同时触发拖拽
                event.stopPropagation();

                this.isResizing = true;
                this.resizeDirection = event.currentTarget.dataset.direction;

                const { screenX, screenY } = event;
                const { x: winX, y: winY, width, height } = await window.electron.ipcRenderer.invoke("get-window-bounds");

                this.startX = screenX;
                this.startY = screenY;
                this.startWinX = winX;
                this.startWinY = winY;
                this.winWidth = width;
                this.winHeight = height;
            }

            resizeWindow(event) {
                if (!this.isResizing) return;
                const { screenX, screenY } = event;
                const deltaX = screenX - this.startX;
                const deltaY = screenY - this.startY;

                let newWinX = this.startWinX;
                let newWinY = this.startWinY;
                let newWidth = this.winWidth;
                let newHeight = this.winHeight;

                const direction = this.resizeDirection;

                // 计算Y轴 (上/下)
                if (direction.includes("top")) {
                    newWinY = this.startWinY + deltaY;
                    newHeight = this.winHeight - deltaY;
                } else if (direction.includes("bottom")) {
                    newHeight = this.winHeight + deltaY;
                }

                // 计算X轴 (左/右)
                if (direction.includes("left")) {
                    newWinX = this.startWinX + deltaX;
                    newWidth = this.winWidth - deltaX;
                } else if (direction.includes("right")) {
                    newWidth = this.winWidth + deltaX;
                }

                // 最小尺寸检查 (防止拉伸过小)
                const minWidth = 100;
                const minHeight = 50;

                if (newWidth < minWidth) {
                    // 如果从左边拉伸，需要修正 x 坐标以保持窗口右边缘不动
                    if (direction.includes("left")) {
                        newWinX = this.startWinX + (this.winWidth - minWidth);
                    }
                    newWidth = minWidth;
                }

                if (newHeight < minHeight) {
                    // 如果从上边拉伸，需要修正 y 坐标以保持窗口下边缘不动
                    if (direction.includes("top")) {
                        newWinY = this.startWinY + (this.winHeight - minHeight);
                    }
                    newHeight = minHeight;
                }


                // 4. 将新的位置和大小发送给主进程。
                window.electron.ipcRenderer.send("resize-window", Math.floor(newWinX), Math.floor(newWinY), Math.floor(newWidth), Math.floor(newHeight));
            }

            /* ---------------------------------------------------- */
            /* 通用事件处理 */
            /* ---------------------------------------------------- */

            handleMove(event) {
                if (this.isDragging) {
                    this.dragWindow(event);
                } else if (this.isResizing) {
                    this.resizeWindow(event);
                }
            }

            endInteraction() {
                this.isDragging = false;
                this.isResizing = false;
                this.resizeDirection = "";
                document.body.classList.remove("is-dragging");
            }
        }

        new LyricsWindow();
    </script>

</body>

</html>